name: üïí Advanced WakaTime Stats Tracker

on:
  schedule:
    - cron: '0 */6 * * *'   # Every 6 hours (consolidated)
  workflow_dispatch:
  push:
    branches: [main, wall-experiments]
    paths:
      - '.github/workflows/wakatime.yml'

concurrency:
  group: wakatime-${{ github.ref }}
  cancel-in-progress: true

jobs:
  wakatime-stats:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: üß≠ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ‚öôÔ∏è Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'

      - name: üì¶ Install Dependencies
        run: pip install -r requirements.txt

      - name: üìä Fetch & Generate WakaTime Stats
        id: wakastats
        env:
          WAKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }}
        run: |
          python <<'EOF'
          import os, json, requests, pytz, base64
          from datetime import datetime, timedelta, timezone

          api_key = os.getenv("WAKATIME_API_KEY")
          if not api_key:
              raise Exception("WAKATIME_API_KEY is missing!")

          # Build explicit date ranges (WakaTime Summaries API requires start and end)
          today_utc = datetime.now(timezone.utc).date()
          
          # This week: last 7 days (today inclusive)
          start_this_week = (today_utc - timedelta(days=6)).strftime('%Y-%m-%d')
          end_this_week = today_utc.strftime('%Y-%m-%d')
          
          # Last week: 7 days before this week (days 7-13 ago)
          start_last_week = (today_utc - timedelta(days=13)).strftime('%Y-%m-%d')
          end_last_week = (today_utc - timedelta(days=7)).strftime('%Y-%m-%d')

          # WakaTime requires base64-encoded API key for Basic auth
          encoded_key = base64.b64encode(api_key.encode()).decode()
          headers = {"Authorization": f"Basic {encoded_key}"}

          # Fetch this week (last 7 days)
          url_this_week = f"https://wakatime.com/api/v1/users/current/summaries?start={start_this_week}&end={end_this_week}"
          res_this_week = requests.get(url_this_week, headers=headers)

          if res_this_week.status_code != 200:
              raise Exception(f"Failed to fetch WakaTime data: {res_this_week.text}")

          data_this_week = res_this_week.json().get("data", [])
          if not data_this_week:
              raise Exception("No data found in WakaTime response.")

          # Fetch last week (days 7-13 ago)
          url_last_week = f"https://wakatime.com/api/v1/users/current/summaries?start={start_last_week}&end={end_last_week}"
          res_last_week = requests.get(url_last_week, headers=headers)
          data_last_week = res_last_week.json().get("data", []) if res_last_week.status_code == 200 else []

          # --- Calculate Weekly Totals ---
          def calculate_total_seconds(data_list):
              total = 0
              for day in data_list:
                  total += day.get("grand_total", {}).get("total_seconds", 0)
              return total

          def format_time(seconds):
              if seconds == 0:
                  return "0 hrs 0 mins"
              hours = int(seconds // 3600)
              minutes = int((seconds % 3600) // 60)
              return f"{hours} hrs {minutes} mins"

          # This week (last 7 days)
          this_week_seconds = calculate_total_seconds(data_this_week)
          this_week_formatted = format_time(this_week_seconds)

          # Last week (days 7-13 ago) - now fetched separately
          last_week_seconds = calculate_total_seconds(data_last_week)
          last_week_formatted = format_time(last_week_seconds)

          print(f"DEBUG: This week data points: {len(data_this_week)}")
          print(f"DEBUG: Last week data points: {len(data_last_week)}")
          print(f"DEBUG: This week seconds: {this_week_seconds}")
          print(f"DEBUG: Last week seconds: {last_week_seconds}")

          # Calculate percentage change
          if last_week_seconds > 0:
              change_percent = ((this_week_seconds - last_week_seconds) / last_week_seconds) * 100
              change_indicator = "üìà" if change_percent > 0 else "üìâ" if change_percent < 0 else "‚û°Ô∏è"
              change_text = f"{change_indicator} {abs(change_percent):.1f}%"
          else:
              change_text = "üÜï New"

          # --- Daily Breakdown for Chart ---
          daily_hours = []
          daily_labels = []
          for day in data_this_week:
              date = day.get("range", {}).get("date", "")
              total_secs = day.get("grand_total", {}).get("total_seconds", 0)
              hours = round(total_secs / 3600, 2)
              daily_hours.append(hours)
              # Format date as Mon, Tue, etc.
              if date:
                  day_name = datetime.strptime(date, "%Y-%m-%d").strftime("%a")
                  daily_labels.append(day_name)
              else:
                  daily_labels.append("N/A")

          # --- Wake-up Coding Time ---
          today_summary = data_this_week[-1] if data_this_week else {}
          first_activity = today_summary.get("range", {}).get("start", "")
          wakeup_time = "N/A"
          if first_activity:
              utc_dt = datetime.fromisoformat(first_activity.replace("Z", "+00:00"))
              wakeup_time = utc_dt.astimezone(pytz.timezone("Asia/Kolkata")).strftime("%H:%M:%S")

          # --- Most Productive Day ---
          if data_this_week:
              most_productive_day = max(data_this_week, key=lambda x: x.get("grand_total", {}).get("total_seconds", 0))
              most_productive_date = most_productive_day.get("range", {}).get("date", "")
              most_productive_hours = round(most_productive_day.get("grand_total", {}).get("total_seconds", 0) / 3600, 2)
              most_productive_day_name = datetime.strptime(most_productive_date, "%Y-%m-%d").strftime("%A") if most_productive_date else "N/A"
          else:
              most_productive_day_name = "N/A"
              most_productive_hours = 0

          # --- Languages & Editors Stats ---
          languages = {}
          editors = {}
          for day in data_this_week:
              for lang in day.get("languages", []):
                  lang_name = lang.get("name", "Unknown")
                  lang_seconds = lang.get("total_seconds", 0)
                  languages[lang_name] = languages.get(lang_name, 0) + lang_seconds
              for editor in day.get("editors", []):
                  editor_name = editor.get("name", "Unknown")
                  editor_seconds = editor.get("total_seconds", 0)
                  editors[editor_name] = editors.get(editor_name, 0) + editor_seconds

          top_language = max(languages.items(), key=lambda x: x[1])[0] if languages else "N/A"
          top_editor = max(editors.items(), key=lambda x: x[1])[0] if editors else "N/A"

          # --- Today and Yesterday Stats ---
          today_data = data_this_week[-1] if len(data_this_week) >= 1 else {}
          yesterday_data = data_this_week[-2] if len(data_this_week) >= 2 else {}
          
          today_seconds = today_data.get("grand_total", {}).get("total_seconds", 0)
          yesterday_seconds = yesterday_data.get("grand_total", {}).get("total_seconds", 0)
          
          today_formatted = format_time(today_seconds)
          yesterday_formatted = format_time(yesterday_seconds)

          # --- Prepare Output Data ---
          output = {
              "generated_at_utc": datetime.now(timezone.utc).isoformat(),
              "wake_up_time": wakeup_time,
              "summary_days": len(data_this_week),
              "latest_day": today_summary.get("range", {}).get("date", ""),
              "total_coding_time": today_summary.get("grand_total", {}).get("text", "0 mins"),
              "today_total": today_formatted,
              "yesterday_total": yesterday_formatted,
              "this_week_total": this_week_formatted,
              "last_week_total": last_week_formatted,
              "this_week_seconds": this_week_seconds,
              "last_week_seconds": last_week_seconds,
              "week_change": change_text,
              "daily_hours": daily_hours,
              "daily_labels": daily_labels,
              "most_productive_day": most_productive_day_name,
              "most_productive_hours": most_productive_hours,
              "top_language": top_language,
              "top_editor": top_editor,
              "raw_data": data_this_week
          }

          # Save JSON for portfolio or future use
          with open("wakatime_stats.json", "w") as f:
              json.dump(output, f, indent=2)

          print(f"Today: {today_formatted}")
          print(f"Yesterday: {yesterday_formatted}")
          print(f"This Week: {this_week_formatted}")
          print(f"Last Week: {last_week_formatted}")
          print(f"Change: {change_text}")
          print(f"Most Productive: {most_productive_day_name} ({most_productive_hours} hrs)")
          EOF

      - name: üß† Update README with Dynamic Stats
        run: |
          python <<'PYEOF'
          import json
          from datetime import datetime, timezone

          # Read the stats
          with open("wakatime_stats.json", "r") as f:
              stats = json.load(f)

          # Read README
          with open("README.md", "r", encoding="utf-8") as f:
              readme = f.read()

          # Update all dynamic fields
          wakeup = stats.get("wake_up_time", "N/A")
          updated = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
          today = stats.get("today_total", "0 hrs 0 mins")
          yesterday = stats.get("yesterday_total", "0 hrs 0 mins")
          this_week = stats.get("this_week_total", "0 hrs 0 mins")
          last_week = stats.get("last_week_total", "0 hrs 0 mins")
          change = stats.get("week_change", "N/A")
          productive_day = stats.get("most_productive_day", "N/A")
          productive_hours = stats.get("most_productive_hours", "0")
          top_lang = stats.get("top_language", "N/A")
          top_editor = stats.get("top_editor", "N/A")

          # Calculate additional metrics
          daily_hours = stats.get("daily_hours", [])
          active_days = sum(1 for h in daily_hours if h > 0)
          avg_daily = sum(daily_hours) / 7 if daily_hours else 0

          # Format for badges (replace spaces with underscores)
          today_badge = today.replace(" ", "_")
          yesterday_badge = yesterday.replace(" ", "_")
          this_week_badge = this_week.replace(" ", "_")
          last_week_badge = last_week.replace(" ", "_")
          change_badge = change.replace(" ", "_").replace("%", "%%25")
          
          # Determine badge color based on change
          change_color = "brightgreen"
          if "üìà" in change:
              change_color = "brightgreen"
          elif "üìâ" in change:
              change_color = "red"
          else:
              change_color = "gray"

          # Create ASCII-style daily chart
          daily_labels = stats.get("daily_labels", [])
          
          # Short day names
          day_names = {
              'Mon': 'Mon', 'Tue': 'Tue', 'Wed': 'Wed',
              'Thu': 'Thu', 'Fri': 'Fri', 'Sat': 'Sat', 'Sun': 'Sun'
          }
          
          chart_lines = []
          max_hours = max(daily_hours) if daily_hours else 1
          
          # Find the most productive day
          most_productive_idx = daily_hours.index(max(daily_hours)) if daily_hours else -1
          
          # Create table header
          chart_lines.append("| Day | Activity | Hours |")
          chart_lines.append("|-----|----------|-------|")
          
          import math
          for i, (label, hours) in enumerate(zip(daily_labels, daily_hours)):
              day = day_names.get(label, label)
              
              # Apply logarithmic scaling for better visual representation
              # This makes small values more visible while still showing differences
              if hours > 0:
                  # Use log scaling: log(1 + hours*10) to amplify small values
                  scaled_value = math.log(1 + hours * 10) / math.log(1 + max_hours * 10)
                  percentage = int(scaled_value * 100)
                  percentage = max(8, min(percentage, 100))  # Min 8% for visibility, max 100%
              else:
                  percentage = 0
              
              # Professional gradient color scheme based on intensity
              if percentage == 0:
                  color = "1a1a2e"  # Very dark blue-gray for no activity
              elif percentage < 25:
                  color = "e94560"  # Coral red for minimal activity
              elif percentage < 50:
                  color = "f39c12"  # Orange for low activity
              elif percentage < 75:
                  color = "3498db"  # Blue for moderate activity
              else:
                  color = "2ecc71"  # Green for high activity
              
              # Add star for most productive day
              star = " ‚≠ê" if i == most_productive_idx and hours > 0 else ""
              
              # Create progress bar using external service
              progress_bar = f"![](https://progress-bar.xyz/{percentage}/?width=250&color={color}&suffix=%20)"
              
              # Format table row
              chart_lines.append(f"| {day} | {progress_bar}{star} | {hours:.1f} hrs |")
          
          chart = "\n".join(chart_lines)

          # Replace badge values in URLs
          import re
          
          # Replace TODAY badge (HTML img tag format)
          readme = re.sub(
              r'(<img src="https://img\.shields\.io/badge/TODAY-)[^-]+(-.+?" alt="TODAY"/>)<!--START_TODAY_BADGE--><!--END_TODAY_BADGE-->',
              rf'\g<1>{today_badge}\g<2><!--START_TODAY_BADGE--><!--END_TODAY_BADGE-->',
              readme
          )
          
          # Replace YESTERDAY badge (HTML img tag format)
          readme = re.sub(
              r'(<img src="https://img\.shields\.io/badge/YESTERDAY-)[^-]+(-.+?" alt="YESTERDAY"/>)<!--START_YESTERDAY_BADGE--><!--END_YESTERDAY_BADGE-->',
              rf'\g<1>{yesterday_badge}\g<2><!--START_YESTERDAY_BADGE--><!--END_YESTERDAY_BADGE-->',
              readme
          )
          
          # Replace THIS WEEK badge (HTML img tag format)
          readme = re.sub(
              r'(<img src="https://img\.shields\.io/badge/THIS_WEEK-)[^-]+(-.+?" alt="THIS WEEK"/>)<!--START_THIS_WEEK_BADGE--><!--END_THIS_WEEK_BADGE-->',
              rf'\g<1>{this_week_badge}\g<2><!--START_THIS_WEEK_BADGE--><!--END_THIS_WEEK_BADGE-->',
              readme
          )
          
          # Replace LAST WEEK badge (HTML img tag format)
          readme = re.sub(
              r'(<img src="https://img\.shields\.io/badge/LAST_WEEK-)[^-]+(-.+?" alt="LAST WEEK"/>)<!--START_LAST_WEEK_BADGE--><!--END_LAST_WEEK_BADGE-->',
              rf'\g<1>{last_week_badge}\g<2><!--START_LAST_WEEK_BADGE--><!--END_LAST_WEEK_BADGE-->',
              readme
          )
          
          # Replace WEEKLY CHANGE badge (both text and color) (HTML img tag format)
          readme = re.sub(
              r'(<img src="https://img\.shields\.io/badge/CHANGE-)[^-]+(-)[^?]+(\?style=for-the-badge&labelColor=1a1a1a" alt="CHANGE"/>)<!--START_WEEK_CHANGE_BADGE--><!--END_WEEK_CHANGE_BADGE--><!--START_CHANGE_COLOR--><!--END_CHANGE_COLOR-->',
              rf'\g<1>{change_badge}\g<2>{change_color}\g<3><!--START_WEEK_CHANGE_BADGE--><!--END_WEEK_CHANGE_BADGE--><!--START_CHANGE_COLOR--><!--END_CHANGE_COLOR-->',
              readme
          )

          # Replace all markers for other dynamic content
          def safe_replace(content, start_marker, end_marker, new_value):
              try:
                  start = content.find(f"<!--{start_marker}-->")
                  end = content.find(f"<!--{end_marker}-->", start)
                  if start != -1 and end != -1:
                      old_content = content[start:end + len(f"<!--{end_marker}-->")]
                      new_content = f"<!--{start_marker}-->{new_value}<!--{end_marker}-->"
                      return content.replace(old_content, new_content, 1)
              except:
                  pass
              return content

          readme = safe_replace(readme, "START_UPDATE_DATE", "END_UPDATE_DATE", updated)
          readme = safe_replace(readme, "START_DAILY_CHART", "END_DAILY_CHART", f"\n{chart}\n")
          
          # Format values for Quick Stats badges (replace spaces with underscores for URL compatibility)
          productive_badge = f"{productive_day} ({productive_hours:.1f}h)".replace(" ", "_")
          top_lang_badge = top_lang.replace(" ", "_")
          top_editor_badge = top_editor.replace(" ", "_")
          avg_daily_badge = f"{avg_daily:.1f} hrs".replace(" ", "_")
          active_days_badge = f"{active_days}/7 days".replace(" ", "_")
          
          # Replace Quick Stats badges - full img tag replacement
          readme = re.sub(
              r'<img src="https://img\.shields\.io/badge/üèÜ_Most_Productive-[^-]+-4CAF50\?style=for-the-badge&labelColor=1a1a1a" alt="Most Productive"/><!--START_PRODUCTIVE_DAY--><!--END_PRODUCTIVE_DAY-->',
              f'<img src="https://img.shields.io/badge/üèÜ_Most_Productive-{productive_badge}-4CAF50?style=for-the-badge&labelColor=1a1a1a" alt="Most Productive"/><!--START_PRODUCTIVE_DAY--><!--END_PRODUCTIVE_DAY-->',
              readme
          )
          
          readme = re.sub(
              r'<img src="https://img\.shields\.io/badge/üíª_Top_Language-[^-]+-2196F3\?style=for-the-badge&labelColor=1a1a1a" alt="Top Language"/><!--START_TOP_LANGUAGE--><!--END_TOP_LANGUAGE-->',
              f'<img src="https://img.shields.io/badge/üíª_Top_Language-{top_lang_badge}-2196F3?style=for-the-badge&labelColor=1a1a1a" alt="Top Language"/><!--START_TOP_LANGUAGE--><!--END_TOP_LANGUAGE-->',
              readme
          )
          
          readme = re.sub(
              r'<img src="https://img\.shields\.io/badge/üõ†Ô∏è_Editor-[^-]+-FF9800\?style=for-the-badge&labelColor=1a1a1a" alt="Editor"/><!--START_TOP_EDITOR--><!--END_TOP_EDITOR-->',
              f'<img src="https://img.shields.io/badge/üõ†Ô∏è_Editor-{top_editor_badge}-FF9800?style=for-the-badge&labelColor=1a1a1a" alt="Editor"/><!--START_TOP_EDITOR--><!--END_TOP_EDITOR-->',
              readme
          )
          
          readme = re.sub(
              r'<img src="https://img\.shields\.io/badge/‚ö°_Avg_Daily-[^-]+-9C27B0\?style=for-the-badge&labelColor=1a1a1a" alt="Avg Daily"/><!--START_AVG_DAILY--><!--END_AVG_DAILY-->',
              f'<img src="https://img.shields.io/badge/‚ö°_Avg_Daily-{avg_daily_badge}-9C27B0?style=for-the-badge&labelColor=1a1a1a" alt="Avg Daily"/><!--START_AVG_DAILY--><!--END_AVG_DAILY-->',
              readme
          )
          
          readme = re.sub(
              r'<img src="https://img\.shields\.io/badge/üìÖ_Active_Days-[^-]+-00BCD4\?style=for-the-badge&labelColor=1a1a1a" alt="Active Days"/><!--START_ACTIVE_DAYS--><!--END_ACTIVE_DAYS-->',
              f'<img src="https://img.shields.io/badge/üìÖ_Active_Days-{active_days_badge}-00BCD4?style=for-the-badge&labelColor=1a1a1a" alt="Active Days"/><!--START_ACTIVE_DAYS--><!--END_ACTIVE_DAYS-->',
              readme
          )

          # Write back
          with open("README.md", "w", encoding="utf-8") as f:
              f.write(readme)

          print(f"‚úÖ README updated successfully!")
          print(f"ÔøΩ Today: {today}")
          print(f"üìÜ Yesterday: {yesterday}")
          print(f"ÔøΩüìä This Week: {this_week}")
          print(f"üìÜ Last Week: {last_week}")
          print(f"üìà Change: {change}")
          print(f"üèÜ Most Productive: {productive_day} ({productive_hours:.1f}h)")
          print(f"‚ö° Avg Daily: {avg_daily:.1f} hrs")
          print(f"üìÖ Active Days: {active_days}/7")
          PYEOF

      - name: üíæ Commit wakatime_stats.json
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git pull --rebase || true
          git add wakatime_stats.json README.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üïí Update WakaTime stats [skip ci]"
            git push
          fi
