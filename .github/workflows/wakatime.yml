name: üïí Advanced WakaTime + Wake-Up Time Tracker

on:
  schedule:
    - cron: '0 0 * * *'     # Daily at midnight UTC
    - cron: '0 */4 * * *'   # Every 4 hours
  workflow_dispatch:

jobs:
  wakatime-stats:
    runs-on: ubuntu-latest

    steps:
      - name: üß≠ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ‚öôÔ∏è Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: üß© Install Dependencies
        run: pip install requests pytz

      - name: üìä Fetch & Generate WakaTime Stats
        id: wakastats
        env:
          WAKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }}
        run: |
          python <<'EOF'
          import os, json, requests, pytz
          from datetime import datetime, timedelta

          api_key = os.getenv("WAKATIME_API_KEY")
          if not api_key:
              raise Exception("WAKATIME_API_KEY is missing!")

          # Fetch last 7 days
          url_last7 = "https://wakatime.com/api/v1/users/current/summaries?range=last_7_days"
          headers = {"Authorization": f"Basic {api_key}"}
          res_last7 = requests.get(url_last7, headers=headers)

          if res_last7.status_code != 200:
              raise Exception(f"Failed to fetch WakaTime data: {res_last7.text}")

          data_last7 = res_last7.json().get("data", [])
          if not data_last7:
              raise Exception("No data found in WakaTime response.")

          # Fetch last 14 days for comparison
          url_last14 = "https://wakatime.com/api/v1/users/current/summaries?range=last_14_days"
          res_last14 = requests.get(url_last14, headers=headers)
          data_last14 = res_last14.json().get("data", []) if res_last14.status_code == 200 else []

          # --- Calculate Weekly Totals ---
          def calculate_total_seconds(data_list):
              total = 0
              for day in data_list:
                  total += day.get("grand_total", {}).get("total_seconds", 0)
              return total

          def format_time(seconds):
              if seconds == 0:
                  return "0 hrs 0 mins"
              hours = int(seconds // 3600)
              minutes = int((seconds % 3600) // 60)
              return f"{hours} hrs {minutes} mins"

          # This week (last 7 days)
          this_week_seconds = calculate_total_seconds(data_last7)
          this_week_formatted = format_time(this_week_seconds)

          # Last week (days 8-14 from the 14-day data)
          last_week_data = data_last14[:7] if len(data_last14) >= 14 else []
          last_week_seconds = calculate_total_seconds(last_week_data)
          last_week_formatted = format_time(last_week_seconds)

          # Calculate percentage change
          if last_week_seconds > 0:
              change_percent = ((this_week_seconds - last_week_seconds) / last_week_seconds) * 100
              change_indicator = "üìà" if change_percent > 0 else "üìâ" if change_percent < 0 else "‚û°Ô∏è"
              change_text = f"{change_indicator} {abs(change_percent):.1f}%"
          else:
              change_text = "üÜï New"

          # --- Daily Breakdown for Chart ---
          daily_hours = []
          daily_labels = []
          for day in data_last7:
              date = day.get("range", {}).get("date", "")
              total_secs = day.get("grand_total", {}).get("total_seconds", 0)
              hours = round(total_secs / 3600, 2)
              daily_hours.append(hours)
              # Format date as Mon, Tue, etc.
              if date:
                  day_name = datetime.strptime(date, "%Y-%m-%d").strftime("%a")
                  daily_labels.append(day_name)
              else:
                  daily_labels.append("N/A")

          # --- Wake-up Coding Time ---
          today_summary = data_last7[-1] if data_last7 else {}
          first_activity = today_summary.get("range", {}).get("start", "")
          wakeup_time = "N/A"
          if first_activity:
              utc_dt = datetime.fromisoformat(first_activity.replace("Z", "+00:00"))
              wakeup_time = utc_dt.astimezone(pytz.timezone("Asia/Kolkata")).strftime("%H:%M:%S")

          # --- Most Productive Day ---
          most_productive_day = max(data_last7, key=lambda x: x.get("grand_total", {}).get("total_seconds", 0))
          most_productive_date = most_productive_day.get("range", {}).get("date", "")
          most_productive_hours = round(most_productive_day.get("grand_total", {}).get("total_seconds", 0) / 3600, 2)
          most_productive_day_name = datetime.strptime(most_productive_date, "%Y-%m-%d").strftime("%A") if most_productive_date else "N/A"

          # --- Languages & Editors Stats ---
          languages = {}
          editors = {}
          for day in data_last7:
              for lang in day.get("languages", []):
                  lang_name = lang.get("name", "Unknown")
                  lang_seconds = lang.get("total_seconds", 0)
                  languages[lang_name] = languages.get(lang_name, 0) + lang_seconds
              for editor in day.get("editors", []):
                  editor_name = editor.get("name", "Unknown")
                  editor_seconds = editor.get("total_seconds", 0)
                  editors[editor_name] = editors.get(editor_name, 0) + editor_seconds

          top_language = max(languages.items(), key=lambda x: x[1])[0] if languages else "N/A"
          top_editor = max(editors.items(), key=lambda x: x[1])[0] if editors else "N/A"

          # --- Prepare Output Data ---
          output = {
              "generated_at_utc": datetime.utcnow().isoformat(),
              "wake_up_time": wakeup_time,
              "summary_days": len(data_last7),
              "latest_day": today_summary.get("range", {}).get("date", ""),
              "total_coding_time": today_summary.get("grand_total", {}).get("text", "0 mins"),
              "this_week_total": this_week_formatted,
              "last_week_total": last_week_formatted,
              "week_change": change_text,
              "daily_hours": daily_hours,
              "daily_labels": daily_labels,
              "most_productive_day": most_productive_day_name,
              "most_productive_hours": most_productive_hours,
              "top_language": top_language,
              "top_editor": top_editor,
              "raw_data": data_last7
          }

          # Save JSON for portfolio or future use
          with open("wakatime_stats.json", "w") as f:
              json.dump(output, f, indent=2)

          print(f"This Week: {this_week_formatted}")
          print(f"Last Week: {last_week_formatted}")
          print(f"Change: {change_text}")
          print(f"Most Productive: {most_productive_day_name} ({most_productive_hours} hrs)")
          EOF

      - name: üß† Update README with Dynamic Stats
        run: |
          python3 <<'PYEOF'
          import json
          from datetime import datetime

          # Read the stats
          with open("wakatime_stats.json", "r") as f:
              stats = json.load(f)

          # Read README
          with open("README.md", "r", encoding="utf-8") as f:
              readme = f.read()

          # Update all dynamic fields
          wakeup = stats.get("wake_up_time", "N/A")
          updated = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
          this_week = stats.get("this_week_total", "0 hrs 0 mins")
          last_week = stats.get("last_week_total", "0 hrs 0 mins")
          change = stats.get("week_change", "N/A")
          productive_day = stats.get("most_productive_day", "N/A")
          productive_hours = stats.get("most_productive_hours", "0")
          top_lang = stats.get("top_language", "N/A")
          top_editor = stats.get("top_editor", "N/A")

          # Calculate additional metrics
          daily_hours = stats.get("daily_hours", [])
          active_days = sum(1 for h in daily_hours if h > 0)
          avg_daily = sum(daily_hours) / 7 if daily_hours else 0

          # Format for badges (replace spaces with underscores)
          this_week_badge = this_week.replace(" ", "_")
          last_week_badge = last_week.replace(" ", "_")
          change_badge = change.replace(" ", "_").replace("%", "%%25")
          
          # Determine badge color based on change
          change_color = "brightgreen"
          if "üìà" in change:
              change_color = "brightgreen"
          elif "üìâ" in change:
              change_color = "red"
          else:
              change_color = "gray"

          # Create ASCII-style daily chart
          daily_labels = stats.get("daily_labels", [])
          
          # Short day names
          day_names = {
              'Mon': 'Mon', 'Tue': 'Tue', 'Wed': 'Wed',
              'Thu': 'Thu', 'Fri': 'Fri', 'Sat': 'Sat', 'Sun': 'Sun'
          }
          
          chart_lines = []
          max_hours = max(daily_hours) if daily_hours else 1
          bar_max_length = 15  # Number of blocks
          
          # Find the most productive day
          most_productive_idx = daily_hours.index(max(daily_hours)) if daily_hours else -1
          
          for i, (label, hours) in enumerate(zip(daily_labels, daily_hours)):
              day = day_names.get(label, label)
              bar_length = int((hours / max_hours) * bar_max_length) if max_hours > 0 else 0
              
              # Use filled and empty blocks
              bar = "‚ñà" * bar_length + "‚ñë" * (bar_max_length - bar_length)
              
              # Add star for most productive day
              star = "  ‚≠ê" if i == most_productive_idx and hours > 0 else ""
              
              # Format: Day  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  X.X hrs
              chart_lines.append(f"{day}  {bar}  {hours:.1f} hrs{star}")
          
          chart = "\n".join(chart_lines)

          # Replace all markers
          def safe_replace(content, start_marker, end_marker, new_value):
              try:
                  start = content.find(f"<!--{start_marker}-->")
                  end = content.find(f"<!--{end_marker}-->", start)
                  if start != -1 and end != -1:
                      old_content = content[start:end + len(f"<!--{end_marker}-->")]
                      new_content = f"<!--{start_marker}-->{new_value}<!--{end_marker}-->"
                      return content.replace(old_content, new_content, 1)
              except:
                  pass
              return content

          readme = safe_replace(readme, "START_THIS_WEEK_BADGE", "END_THIS_WEEK_BADGE", this_week_badge)
          readme = safe_replace(readme, "START_LAST_WEEK_BADGE", "END_LAST_WEEK_BADGE", last_week_badge)
          readme = safe_replace(readme, "START_WEEK_CHANGE_BADGE", "END_WEEK_CHANGE_BADGE", change_badge)
          readme = safe_replace(readme, "START_CHANGE_COLOR", "END_CHANGE_COLOR", change_color)
          readme = safe_replace(readme, "START_UPDATE_DATE", "END_UPDATE_DATE", updated)
          readme = safe_replace(readme, "START_DAILY_CHART", "END_DAILY_CHART", f"\n```\n{chart}\n```\n")
          readme = safe_replace(readme, "START_PRODUCTIVE_DAY", "END_PRODUCTIVE_DAY", f"{productive_day} ({productive_hours:.1f}h)")
          readme = safe_replace(readme, "START_TOP_LANGUAGE", "END_TOP_LANGUAGE", top_lang)
          readme = safe_replace(readme, "START_TOP_EDITOR", "END_TOP_EDITOR", top_editor)
          readme = safe_replace(readme, "START_AVG_DAILY", "END_AVG_DAILY", f"{avg_daily:.1f} hrs")
          readme = safe_replace(readme, "START_ACTIVE_DAYS", "END_ACTIVE_DAYS", f"{active_days}/7")

          # Write back
          with open("README.md", "w", encoding="utf-8") as f:
              f.write(readme)

          print(f"‚úÖ README updated successfully!")
          print(f"üìä This Week: {this_week}")
          print(f"üìÜ Last Week: {last_week}")
          print(f"üìà Change: {change}")
          print(f"üèÜ Most Productive: {productive_day} ({productive_hours:.1f}h)")
          print(f"‚ö° Avg Daily: {avg_daily:.1f} hrs")
          print(f"üìÖ Active Days: {active_days}/7")
          PYEOF

      - name: üßÆ Update Coding Breakdown (WakaTime Chart)
        uses: athul/waka-readme@master
        with:
          WAKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }}
          TIME_RANGE: last_7_days
          LANG_COUNT: 10
          SHOW_TITLE: true
          SHOW_TIME: true
          SHOW_TOTAL: true
          SECTION_NAME: üìä Coding_Stats
          COMMIT_MESSAGE: "üìä Auto-update: WakaTime stats + wake-up time"
          TARGET_BRANCH: main
          TARGET_PATH: README.md

      - name: üíæ Commit wakatime_stats.json
        run: |
          git config --global user.name "GitHub Action Bot"
          git config --global user.email "github-action-bot@users.noreply.github.com"
          git add wakatime_stats.json README.md
          git commit -m "üïí Updated WakaTime JSON and README" || echo "No changes to commit"
          git push origin main